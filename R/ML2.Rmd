---
title: "ML2"
author: "Carla"
date: "2024-04-08"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(phyloseq)
library(mlr3)
library(mlr3learners)
library(mlr3tuning)
library(mlr3pipelines)
library(ranger)
library(caret)
```

# Experimento 2 - Leave cohort out variable Status (CRC/Control)

```{r include=TRUE}
# PRE MOBER 
physeq_pre <- subset_samples(physeq_agl_combined, sample_data(physeq_output_clr)$status != "adenoma")

otu_table <- t(otu_table(physeq_pre))
otu_table <- as.matrix(otu_table)
status <- sample_data(physeq_pre)$status
project <- sample_data(physeq_pre)$project

data_ml_pre <- cbind(otu_table, status, project)
data_ml_pre <- as.data.frame(data_ml_pre)
data_ml_pre$status <- as.factor(data_ml_pre$status)
data_ml_pre$project <- as.factor(data_ml_pre$project)

for (col in names(data_ml_pre)) {
  if (is.character(data_ml_pre[[col]]) || is.factor(data_ml_pre[[col]])) {
    data_ml_pre[[col]] <- as.numeric(data_ml_pre[[col]])
  }
}

data_ml_pre$status <- factor(data_ml_pre$status)
data_ml_pre$project <- factor(data_ml_pre$project)


# POST MOBER
physeq_post <- subset_samples(physeq_output_clr, sample_data(physeq_output_clr)$status != "adenoma")

otu_table <- otu_table(physeq_post)
otu_table <- as.matrix(otu_table)
status <- sample_data(physeq_output_clr_filtrado)$status
project <- sample_data(physeq_output_clr_filtrado)$project

data_ml_post <- cbind(otu_table, status, project)
data_ml_post <- as.data.frame(data_ml_post)
data_ml_post$status <- as.factor(data_ml_post$status)
data_ml_post$project <- as.factor(data_ml_post$project)

for (col in names(data_ml_post)) {
  if (is.character(data_ml_post[[col]]) || is.factor(data_ml_post[[col]])) {
    data_ml_post[[col]] <- as.numeric(data_ml_post[[col]])
  }
}

data_ml_post$status <- factor(data_ml_post$status)
data_ml_post$project <- factor(data_ml_post$project)

# cancer = 1, normal = 2

# Lo que hay que hacer: leave cohort out es entrenar con 6 cohortes y dejar la 7 para test y así para todas. Por lo tanto, separar data_ml con respecto a las cohortes para tener 6 muestras. La variable que queremos predecir es status (cancer o normal) --> será la que se meta en la task como target. Igual que el experimento anterior pero cambiando el método de resampling para hacerlo con LOCO. 
```

```{r include=TRUE}

task <- TaskClassif$new(id = "status", backend = data_ml, target = "status")

# Verificar las cohortes disponibles
cohortes <- unique(data_ml$project)
print(cohortes)

# Crear el objeto de validación cruzada personalizada
custom_cv <- rsmp("custom_cv")

# Definir las particiones
f <- as.factor(data_ml$project)

# Instanciar la validación cruzada personalizada
custom_cv$instantiate(task, f = f)


# Ejemplo: obtener los conjuntos de entrenamiento y prueba para la primera iteración
train_set <- custom_cv$train_set(1)
test_set <- custom_cv$test_set(1)

print(train_set)
print(test_set)

# Puedes visualizar los datos de entrenamiento y prueba si lo deseas
data_ml[train_set, ]
data_ml[test_set, ]
```

```{r include=TRUE}

run_ml_pipeline <- function(data_ml_pre, data_ml_post, model) {

  # Definición tasks
  if (model == "svm") {
    task_pre <- TaskClassif$new(id = "ml2_svm", backend = data_ml_pre, target = "status")
    task_post <- TaskClassif$new(id = "ml2_svm_post", backend = data_ml_post, target = "status")
  } else if (model == "rf") {
    task_pre <- TaskClassif$new(id = "ml2_rf", backend = data_ml_pre, target = "status")
    task_post <- TaskClassif$new(id = "ml2_rf_post", backend = data_ml_post, target = "status")
  } else if (model == "glmn") {
    task_pre <- TaskClassif$new(id = "ml2_rf", backend = data_ml_pre, target = "status")
    task_post <- TaskClassif$new(id = "ml2_rf_post", backend = data_ml_post, target = "status")
  }
  
  # Modelo de aprendizaje automático
  if (model == "svm") {
    learner <- lrn("classif.svm")
  } else if (model == "rf") {
    learner <- lrn("classif.ranger")
  } else if (model == "glmn") {
    learner <- lrn("classif.glmnet")
  }
  
  # Crear el objeto de validación cruzada personalizada
  custom_cv_pre <- rsmp("custom_cv")
  custom_cv_post <- rsmp("custom_cv")
  
  # Definir las particiones basadas en la columna 'project'
  f_pre <- as.factor(data_ml_pre$project)
  f_post <- as.factor(data_ml_post$project)
  
  # Instanciar la validación cruzada personalizada
  custom_cv_pre$instantiate(task_pre, f = f_pre)
  custom_cv_post$instantiate(task_post, f = f_post)
  
  # Proceso de evaluación
  eval_pre <- mlr3::resample(task = task_pre, learner = learner, resampling = resampling)
  eval_post <- mlr3::resample(task = task_post, learner = learner, resampling = resampling)
  
  # Obtención métricas
  result_ce_pre <- eval_pre$aggregate(measures = msr("classif.ce"))
  result_bacc_pre <- eval_pre$aggregate(measures = msr("classif.bacc"))
  
  result_ce_post <- eval_post$aggregate(measures = msr("classif.ce"))
  result_bacc_post <- eval_post$aggregate(measures = msr("classif.bacc"))
  
  # Resultados por iteración (para ver el rendimiento en cada cohorte)
  results_by_fold_pre <- lapply(seq_len(custom_cv_pre$iters), function(i) {
    train_set <- custom_cv_pre$train_set(i)
    test_set <- custom_cv_pre$test_set(i)
    list(
      train_cohort = unique(data_pre$project[train_set]),
      test_cohort = unique(data_pre$project[test_set]),
      ce = eval_pre$resample_result(i)$score(msr("classif.ce")),
      bacc = eval_pre$resample_result(i)$score(msr("classif.bacc"))
    )
  })
  
  results_by_fold_post <- lapply(seq_len(custom_cv_post$iters), function(i) {
    train_set <- custom_cv_post$train_set(i)
    test_set <- custom_cv_post$test_set(i)
    list(
      train_cohort = unique(data_post$project[train_set]),
      test_cohort = unique(data_post$project[test_set]),
      ce = eval_post$resample_result(i)$score(msr("classif.ce")),
      bacc = eval_post$resample_result(i)$score(msr("classif.bacc"))
    )
  })
  
  # Resultados
  return(list(ce_pre = result_ce_pre, 
              ce_post = result_ce_post, 
              bacc_pre = result_bacc_pre, 
              bacc_post = result_bacc_post,
              results_by_fold_pre = results_by_fold_pre,
              results_by_fold_post = results_by_fold_post))
}

results_svm <- run_ml_pipeline(data_ml_pre, data_ml_post, "svm")
results_rf <- run_ml_pipeline(data, "rf")
results_glmn <- run_ml_pipeline(data, "glmn")
```